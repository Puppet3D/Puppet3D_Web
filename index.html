<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>PPTest</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <section class="hero-section" id="hero-section">
    <div class="hero-section__inner">
      <p class="hero-section__kicker">Featured</p>
      <h1 class="hero-section__headline">
        <span class="hero-section__headline-line">Create.</span>
        <span class="hero-section__headline-line">Ship.</span>
        <span class="hero-section__headline-line">Repeat.</span>
      </h1>
      <div class="hero-section__featured-card">
        <span class="hero-section__card-tag">Script</span>
        <p class="hero-section__card-title">Easy Assign Material</p>
        <p class="hero-section__card-desc">Tu flujo en un solo lugar.</p>
      </div>
      <div class="hero-section__ctas">
        <a href="#content" class="hero-section__cta hero-section__cta--primary">Ver proyectos</a>
        <a href="#" class="hero-section__cta hero-section__cta--secondary">Saber más</a>
      </div>
    </div>
  </section>

  <main class="page" id="content">
    <section class="grid">
      <article class="card c1" data-tags="ux">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>1 · Diseño UI + animaciones suaves</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="videos/Easy Assign Material.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>1 · Stack: HTML, CSS, JS. Enfoque en conversión y performance.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>

      <article class="card c2" data-tags="dev">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">Dev</span>
            <p>2 · Analítica en tiempo real</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">Dev</span>
              <p>2 · Componentes reutilizables y gráficos responsivos.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>

      <article class="card c3" data-tags="ux">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>3 · Checkout optimizado</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>3 · Mejora de UX y tasas de conversión.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>

      <article class="card c4" data-tags="dev">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">Dev</span>
            <p>4 · Interacciones micro-animadas</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">Dev</span>
              <p>4 · Prototipado rápido y pruebas con usuarios.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>

      <article class="card c5" data-tags="ux">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>5 · Wireframes y prototipos rápidos</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>5 · Iteración con feedback y pruebas A/B.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>

      <article class="card c1" data-tags="dev">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">Dev</span>
            <p>6 · Automatización y scripts internos</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">Dev</span>
              <p>6 · Herramientas para acelerar el flujo de trabajo.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>

      <article class="card c2" data-tags="ux">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>7 · Research y entrevistas a usuarios</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>7 · Hallazgos clave y recomendaciones.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>

      <article class="card c3" data-tags="dev">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">Dev</span>
            <p>8 · Integraciones con APIs externas</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">Dev</span>
              <p>8 · Conectores y sincronización de datos.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>

      <article class="card c4" data-tags="ux">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>9 · Accesibilidad y mejoras de contraste</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>9 · Auditoría y ajustes de accesibilidad.</p>
              <a class="cta" href="#">Ver caso</a>
            </div>
          </div>
        </div>
        <div class="muppet" aria-hidden="true"><img src="images/muppet%2002.png" alt="" class="muppet-default" /><img src="images/muppet.png" alt="" class="muppet-hover" /></div>
      </article>
    </section>
  </main>

  <aside class="muppet-ui" aria-label="Ajustar muppet">
    <h3 class="muppet-ui__title">Muppet</h3>
    <label class="muppet-ui__row">
      <span>Right (px)</span>
      <input type="number" id="muppet-right" value="-54" />
    </label>
    <label class="muppet-ui__row">
      <span>Bottom (px)</span>
      <input type="number" id="muppet-bottom" value="-52" />
    </label>
    <label class="muppet-ui__row">
      <span>Tamaño (px)</span>
      <input type="number" id="muppet-size" value="140" min="40" />
    </label>
    <label class="muppet-ui__row">
      <span>Gap cards (px)</span>
      <input type="number" id="grid-gap" value="56" min="0" />
    </label>
  </aside>

  <aside class="scroll-ui" aria-label="Diagnóstico de scroll">
    <h3 class="scroll-ui__title">Scroll Debug</h3>
    <div class="scroll-ui__row">
      <span>Y (px)</span>
      <output id="dbg-scroll-y">0</output>
    </div>
    <div class="scroll-ui__row">
      <span>Página</span>
      <output id="dbg-page-progress">0%</output>
    </div>
    <div class="scroll-ui__row">
      <span>Hero</span>
      <output id="dbg-hero-progress">0%</output>
    </div>
    <div class="scroll-ui__row">
      <span>Rango hero</span>
      <output id="dbg-hero-range">0 - 0</output>
    </div>
    <div class="scroll-ui__row">
      <span>Cards top</span>
      <output id="dbg-content-top">0px</output>
    </div>
    <div class="scroll-ui__row">
      <span>Dirección</span>
      <output id="dbg-scroll-direction">idle</output>
    </div>
    <div class="scroll-ui__bar" aria-hidden="true">
      <span class="scroll-ui__bar-fill" id="dbg-page-bar"></span>
    </div>
  </aside>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
  <script>
    (function muppetControls() {
      const root = document.documentElement;
      const rightInput = document.getElementById("muppet-right");
      const bottomInput = document.getElementById("muppet-bottom");
      const sizeInput = document.getElementById("muppet-size");
      const gapInput = document.getElementById("grid-gap");
      function apply() {
        root.style.setProperty("--muppet-right", (rightInput.value | 0) + "px");
        root.style.setProperty("--muppet-bottom", (bottomInput.value | 0) + "px");
        root.style.setProperty("--muppet-size", (sizeInput.value | 0) + "px");
        root.style.setProperty("--grid-gap", (gapInput.value | 0) + "px");
      }
      [rightInput, bottomInput, sizeInput, gapInput].forEach((el) => {
        el.addEventListener("input", apply);
        el.addEventListener("change", apply);
      });
      apply();
    })();

    (function heroSection() {
      if (typeof gsap === "undefined") return;
      if (typeof ScrollTrigger !== "undefined") gsap.registerPlugin(ScrollTrigger);

      const hero = document.getElementById("hero-section");
      const headlineLines = document.querySelectorAll(".hero-section__headline-line");
      const kicker = document.querySelector(".hero-section__kicker");
      const featuredCard = document.querySelector(".hero-section__featured-card");
      const ctas = document.querySelector(".hero-section__ctas");
      const content = document.getElementById("content");
      const dbgScrollY = document.getElementById("dbg-scroll-y");
      const dbgPageProgress = document.getElementById("dbg-page-progress");
      const dbgHeroProgress = document.getElementById("dbg-hero-progress");
      const dbgHeroRange = document.getElementById("dbg-hero-range");
      const dbgContentTop = document.getElementById("dbg-content-top");
      const dbgDirection = document.getElementById("dbg-scroll-direction");
      const dbgPageBar = document.getElementById("dbg-page-bar");

      if (!hero) return;

      const getScrollDistance = () => Math.max(window.innerHeight, 1);
      let lastScrollY = Math.round(window.scrollY || 0);

      const toPct = (value) => `${Math.round(value * 100)}%`;
      const setText = (el, value) => {
        if (el) el.textContent = value;
      };
      const updateScrollDebug = () => {
        const scrollY = Math.round(window.scrollY || 0);
        const maxScroll = Math.max(
          document.documentElement.scrollHeight - window.innerHeight,
          1
        );
        const pageProgress = Math.min(1, Math.max(0, scrollY / maxScroll));
        const heroStart = 0;
        const heroEnd = Math.round(getScrollDistance());
        const heroProgress = Math.min(
          1,
          Math.max(0, (scrollY - heroStart) / Math.max(heroEnd - heroStart, 1))
        );
        const contentTop = content
          ? Math.round(content.getBoundingClientRect().top)
          : 0;

        let direction = "idle";
        if (scrollY > lastScrollY) direction = "down";
        else if (scrollY < lastScrollY) direction = "up";

        setText(dbgScrollY, String(scrollY));
        setText(dbgPageProgress, toPct(pageProgress));
        setText(dbgHeroProgress, toPct(heroProgress));
        setText(dbgHeroRange, `${heroStart} - ${heroEnd}`);
        setText(dbgContentTop, `${contentTop}px`);
        setText(dbgDirection, direction);
        if (dbgPageBar) dbgPageBar.style.width = `${Math.round(pageProgress * 100)}%`;

        lastScrollY = scrollY;
      };

      const tl = gsap.timeline({ defaults: { ease: "power3.out" } });
      tl.set(hero, { opacity: 1 })
        .fromTo(kicker, { opacity: 0, y: 12 }, { opacity: 1, y: 0, duration: 0.6 })
        .fromTo(
          headlineLines,
          { opacity: 0, y: "1.2em" },
          { opacity: 1, y: 0, duration: 0.7, stagger: 0.12, delay: 0.1 }
        )
        .fromTo(
          featuredCard,
          { opacity: 0, y: 24 },
          { opacity: 1, y: 0, duration: 0.8 },
          "-=0.3"
        )
        .fromTo(ctas, { opacity: 0, y: 16 }, { opacity: 1, y: 0, duration: 0.5 }, "-=0.4");

      gsap.to(featuredCard, {
        y: -10,
        duration: 2.2,
        repeat: -1,
        yoyo: true,
        ease: "sine.inOut",
      });

      window.addEventListener("scroll", updateScrollDebug, { passive: true });
      window.addEventListener("resize", updateScrollDebug);
      if (typeof ScrollTrigger !== "undefined") {
        ScrollTrigger.addEventListener("refresh", updateScrollDebug);
      }
      updateScrollDebug();
    })();

    const cards = Array.from(document.querySelectorAll(".card"));

    let expandedCard = null;

    cards.forEach((card) => {
      const video = card.querySelector(".card-video");
      if (!video) return;

      card.addEventListener("mouseenter", () => {
        video.currentTime = 0;
        video.play().catch(() => {});
      });

      card.addEventListener("mouseleave", () => {
        if (card.classList.contains("is-expanded")) return;
        if (expandedCard === card) return;
        video.pause();
      });
    });

    const expandDuration = 700;
    const expandEasing = "cubic-bezier(0.2, 0.7, 0.2, 1)";

    const makeCubicBezier = (p1x, p1y, p2x, p2y) => {
      const cx = 3 * p1x;
      const bx = 3 * (p2x - p1x) - cx;
      const ax = 1 - cx - bx;
      const cy = 3 * p1y;
      const by = 3 * (p2y - p1y) - cy;
      const ay = 1 - cy - by;

      const sampleX = (t) => ((ax * t + bx) * t + cx) * t;
      const sampleY = (t) => ((ay * t + by) * t + cy) * t;
      const sampleDerivX = (t) => (3 * ax * t + 2 * bx) * t + cx;

      return (x) => {
        let t = x;
        for (let i = 0; i < 6; i += 1) {
          const dx = sampleX(t) - x;
          const d = sampleDerivX(t);
          if (Math.abs(dx) < 1e-5 || Math.abs(d) < 1e-5) break;
          t -= dx / d;
        }
        return sampleY(t);
      };
    };

    const easeExpand = makeCubicBezier(0.2, 0.7, 0.2, 1);

    const centerCardInView = (card) => {
      const getTarget = () => {
        const rect = card.getBoundingClientRect();
        const targetY =
          window.scrollY + rect.top + rect.height / 2 - window.innerHeight / 2;
        const maxScroll =
          document.documentElement.scrollHeight - window.innerHeight;
        return Math.max(0, Math.min(targetY, maxScroll));
      };

      const startTime = performance.now();
      const tick = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / expandDuration, 1);
        const eased = easeExpand(t);
        const target = getTarget();
        const current = window.scrollY;
        window.scrollTo(0, current + (target - current) * eased);
        if (t < 1) {
          requestAnimationFrame(tick);
        }
      };

      requestAnimationFrame(tick);
    };

    const animateReflow = () => {
      if (reduceMotion) return;
      const firstRects = new Map();
      cards.forEach((card) => firstRects.set(card, card.getBoundingClientRect()));
      requestAnimationFrame(() => {
        cards.forEach((card) => {
          const first = firstRects.get(card);
          const last = card.getBoundingClientRect();
          if (!first) return;
          const dx = first.left - last.left;
          const dy = first.top - last.top;
          if (dx || dy) {
            card.animate(
              [
                { transform: `translate(${dx}px, ${dy}px)` },
                { transform: "translate(0, 0)" },
              ],
              { duration: expandDuration, easing: expandEasing }
            );
          }
        });
      });
    };

    const renderMissingSlots = (missingSlots, cols, gridRect, cellSize, gap) => {
      const grid = document.querySelector(".grid");
      const existing = Array.from(grid.querySelectorAll(".missing-slot"));
      if (!missingSlots.length) {
        existing.forEach((el) => {
          el.classList.add("missing-leave");
          setTimeout(() => el.remove(), 250);
        });
        return;
      }
      existing.forEach((el) => el.remove());
      missingSlots.forEach((slot) => {
        const row = Math.ceil(slot / cols);
        const col = slot - (row - 1) * cols;
        const placeholder = document.createElement("div");
        placeholder.className = "card missing-slot";
        const top = (row - 1) * (cellSize + gap);
        const left = (col - 1) * (cellSize + gap);
        placeholder.style.position = "absolute";
        placeholder.style.top = `${top}px`;
        placeholder.style.left = `${left}px`;
        placeholder.style.width = `${cellSize}px`;
        placeholder.style.height = `${cellSize}px`;
        placeholder.innerHTML = `<div class="missing-label">Hueco ${slot}</div>`;
        grid.appendChild(placeholder);
        requestAnimationFrame(() => placeholder.classList.add("is-visible"));
      });
    };

    const clearMissingSlotsImmediate = () => {
      const grid = document.querySelector(".grid");
      const existing = Array.from(grid.querySelectorAll(".missing-slot"));
      existing.forEach((el) => {
        el.classList.add("missing-leave");
        setTimeout(() => el.remove(), 250);
      });
    };

    const updateCardPositions = (logMissing = false, renderMissing = false) => {
      if (typeof log === "function") log("11a. updateCardPositions inicio");
      const grid = document.querySelector(".grid");
      const gridStyle = getComputedStyle(grid);
      const gap = parseFloat(gridStyle.gap) || 0;
      const columns = gridStyle.gridTemplateColumns.split(" ");
      const cols = columns.length;
      const gridRect = grid.getBoundingClientRect();
      const cellSize =
        cols > 0 ? (gridRect.width - gap * (cols - 1)) / cols : 0;
      const cellStep = cellSize + gap;

      const slotMap = new Map();
      cards.forEach((card) => slotMap.set(card, []));

      cards.forEach((card) => {
        const rect = card.getBoundingClientRect();
        const col = Math.max(
          1,
          Math.floor((rect.left - gridRect.left + 1) / cellStep) + 1
        );
        const row = Math.max(
          1,
          Math.floor((rect.top - gridRect.top + 1) / cellStep) + 1
        );
        const colSpan = Math.max(
          1,
          Math.round((rect.width + gap) / cellStep)
        );
        const rowSpan = Math.max(
          1,
          Math.round((rect.height + gap) / cellStep)
        );

        const slots = [];
        for (let r = row; r < row + rowSpan; r += 1) {
          for (let c = col; c < col + colSpan; c += 1) {
            slots.push((r - 1) * cols + c);
          }
        }
        slotMap.set(card, slots);
      });

      cards.forEach((card) => {
        const label = slotMap.get(card).join(", ");
        card.querySelectorAll(".card-front p").forEach((p) => {
          const text = p.textContent.replace(/^\d+(,\s*\d+)*\s·\s/, "");
          p.textContent = `${label} · ${text}`;
        });
        card.querySelectorAll(".card-back-content p").forEach((p) => {
          const text = p.textContent.replace(/^\d+(,\s*\d+)*\s·\s/, "");
          p.textContent = `${label} · ${text}`;
        });
      });

      const expanded = document.querySelector(".card.is-expanded");
      if (expanded && renderMissing) {
        let maxSlot = 0;
        slotMap.forEach((slots) => {
          slots.forEach((slot) => {
            if (slot > maxSlot) maxSlot = slot;
          });
        });
        const totalSlots = maxSlot;
        const used = new Set();
        slotMap.forEach((slots) => slots.forEach((slot) => used.add(slot)));
        const missing = [];
        for (let i = 1; i <= totalSlots; i += 1) {
          if (!used.has(i)) missing.push(i);
        }
        renderMissingSlots(missing, cols, gridRect, cellSize, gap);
        if (logMissing) {
          console.log(
            "Slots faltantes:",
            missing.length ? missing.join(", ") : "ninguno"
          );
        }
      } else if (!expanded) {
        renderMissingSlots([], cols, gridRect, cellSize, gap);
      }
      if (typeof log === "function") log("11b. updateCardPositions fin");
    };

    let expandRunId = 0;

    const finalizeMissingSlots = (runId) => {
      log("9. finalizeMissingSlots llamado runId=", runId);
      setTimeout(() => {
        if (runId !== expandRunId) {
          log("10. finalizeMissingSlots ignorado (runId distinto)");
          return;
        }
        log("11. updateCardPositions(true, true)");
        updateCardPositions(true, true);
      }, 0);
    };

    const DEBUG_EXPAND = true; // poner false para quitar logs
    const log = (...args) => DEBUG_EXPAND && console.log("[expand]", ...args);

    const toggleExpand = (card) => {
      log("1. toggleExpand inicio");
      clearMissingSlotsImmediate();
      cards.forEach((c) => {
        c.getAnimations().forEach((a) => a.cancel());
      });
      expandRunId += 1;
      const runId = expandRunId;
      const firstRects = new Map();
      const grid = document.querySelector(".grid");
      const gridCenterX = grid.getBoundingClientRect().left + grid.getBoundingClientRect().width / 2;
      const rowTops = [];
      if (!reduceMotion) {
        cards.forEach((c) => firstRects.set(c, c.getBoundingClientRect()));
      }
      cards.forEach((c) => {
        const rect = firstRects.get(c) || c.getBoundingClientRect();
        const top = Math.round(rect.top);
        const match = rowTops.find((t) => Math.abs(t - top) < 2);
        if (match === undefined) {
          rowTops.push(top);
        }
      });
      rowTops.sort((a, b) => a - b);

      const isExpanded = card.classList.contains("is-expanded");
      log("2. isExpanded=", isExpanded, "runId=", runId);
      document
        .querySelectorAll(".card.is-expanded")
        .forEach((c) => c.classList.remove("is-expanded"));
      cards.forEach((c) => {
        c.style.gridRowStart = "";
      });
      if (!isExpanded) {
        log("3a. expandiendo: aplicando gridRowStart y clase");
        const rect = firstRects.get(card) || card.getBoundingClientRect();
        const rowIndex = rowTops.findIndex((t) => Math.abs(t - Math.round(rect.top)) < 2);
        if (rowIndex !== -1) {
          card.style.gridRowStart = String(rowIndex + 1);
        }
        card.classList.add("is-expanded");
        expandedCard = card;
        // video se reproduce al terminar la animación para no bloquear (video pesado)
      } else {
        log("3a. colapsando");
        expandedCard = null;
        const video = card.querySelector(".card-video");
        if (video) {
          video.pause();
          setTimeout(() => {
            video.load();
          }, 300);
        }
      }

      const animations = [];
      if (!reduceMotion) {
        log("4. encolando rAF para animaciones");
        requestAnimationFrame(() => {
          log("5. rAF: iniciando animaciones, cards=", cards.length);
          const isExpanding = !isExpanded;
          cards.forEach((c) => {
            const first = firstRects.get(c);
            const last = c.getBoundingClientRect();
            if (!first) return;
            const isTarget = c === card;
            const sx = first.width / last.width;
            const sy = first.height / last.height;
            const useScale = isTarget && (sx !== 1 || sy !== 1);
            const originRect = isExpanding ? first : last;
            const isRight =
              originRect.left + originRect.width / 2 >= gridCenterX;
            const origin = isRight ? "top right" : "top left";
            const dx = isRight ? first.right - last.right : first.left - last.left;
            const dy = isTarget ? 0 : first.top - last.top;
            if (dx || dy || useScale) {
              const anim = c.animate(
                [
                  {
                    transform: useScale
                      ? `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})`
                      : `translate(${dx}px, ${dy}px)`,
                    transformOrigin: origin,
                  },
                  {
                    transform: useScale
                      ? "translate(0, 0) scale(1, 1)"
                      : "translate(0, 0)",
                    transformOrigin: origin,
                  },
                ],
                  { duration: expandDuration, easing: expandEasing }
              );
              animations.push(anim);
            }
          });
          log("6. animaciones lanzadas:", animations.length);

          if (animations.length) {
            Promise.all(animations.map((anim) => anim.finished))
              .then(() => {
                log("7. animaciones terminadas, finalizeMissingSlots");
                finalizeMissingSlots(runId);
                const expanded = document.querySelector(".card.is-expanded");
                if (expanded) {
                  const video = expanded.querySelector(".card-video");
                  if (video) {
                    log("7b. video.play() tras animación");
                    video.play().catch((e) => log("video.play error", e));
                  }
                }
              })
              .catch((e) => {
                log("7. animaciones error", e);
                finalizeMissingSlots(runId);
              });
          } else {
            log("7. sin animaciones, finalizeMissingSlots directo");
            finalizeMissingSlots(runId);
            const expanded = document.querySelector(".card.is-expanded");
            if (expanded) {
              const video = expanded.querySelector(".card-video");
              if (video) {
                log("7b. video.play() tras animación");
                video.play().catch((e) => log("video.play error", e));
              }
            }
          }
        });
      }
      if (reduceMotion) {
        finalizeMissingSlots(runId);
      }
      log("8. toggleExpand fin (sync)");
    };

    cards.forEach((card) => {
      card.addEventListener("click", (event) => {
        const expanded = card.classList.contains("is-expanded");
        if (!expanded && !card.matches(":hover")) return; // expandir solo con hover
        if (event.target.closest(".cta")) {
          event.preventDefault();
        }
        log("0. click en card");
        toggleExpand(card);
      });
    });

    const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    let activeFilter = "all";

    const applyFilter = (filter) => {
      const grid = document.querySelector(".grid");
      const leaveDuration = 300; // velocidad de aparición/desaparición
      const cardRects = new Map();
      const matchesMap = new Map();
      const enteringCards = new Set();
      const gridRect = grid.getBoundingClientRect();
      const firstRects = new Map();

      cards.forEach((card) => {
        cardRects.set(card, card.getBoundingClientRect());
        const tags = (card.dataset.tags || "").split(",").map((t) => t.trim());
        const matches = filter === "all" || tags.includes(filter);
        matchesMap.set(card, matches);
        if (!reduceMotion && matches) {
          firstRects.set(card, cardRects.get(card));
        }
      });

      cards.forEach((card) => {
        const matches = matchesMap.get(card);
        const wasRemoved = card.classList.contains("is-removed");

        if (matches) {
          if (wasRemoved) {
            enteringCards.add(card);
            card.classList.add("is-entering");
            requestAnimationFrame(() => card.classList.remove("is-entering"));
          }
          card.classList.remove("is-removed", "is-hidden", "is-leaving");
          card.style.position = "";
          card.style.top = "";
          card.style.left = "";
          card.style.width = "";
          card.style.height = "";
          return;
        }

        const rect = cardRects.get(card);
        const top = rect.top - gridRect.top;
        const left = rect.left - gridRect.left;
        card.style.position = "absolute";
        card.style.top = `${top}px`;
        card.style.left = `${left}px`;
        card.style.width = `${rect.width}px`;
        card.style.height = `${rect.height}px`;
        card.classList.add("is-leaving");
        requestAnimationFrame(() => card.classList.add("is-hidden"));

        setTimeout(() => {
          if (!matchesMap.get(card)) {
            card.classList.remove("is-leaving", "is-hidden");
            card.classList.add("is-removed");
            card.style.position = "";
            card.style.top = "";
            card.style.left = "";
            card.style.width = "";
            card.style.height = "";
          }
        }, leaveDuration);
      });

      if (!reduceMotion) {
        requestAnimationFrame(() => {
          cards.forEach((card) => {
            if (!matchesMap.get(card)) return;
            if (enteringCards.has(card)) return; // B solo: no animar reacomodo
            const first = firstRects.get(card);
            const last = card.getBoundingClientRect();
            if (!first) return;
            const dx = first.left - last.left;
            const dy = first.top - last.top;
            if (dx || dy) {
              card.animate(
                [
                  { transform: `translate(${dx}px, ${dy}px)` },
                  { transform: "translate(0, 0)" },
                ],
                { duration: 820, easing: "cubic-bezier(0.2, 0.7, 0.2, 1)" } // velocidad del reacomodo (sube este duration)
              );
            }
          });
        });
      }
      requestAnimationFrame(() => updateCardPositions(false, false));
    };

    requestAnimationFrame(() => updateCardPositions(false, false));

    document.querySelectorAll(".card-tag").forEach((tag) => {
      tag.addEventListener("click", (event) => {
        event.stopPropagation();
        const label = tag.textContent.trim().toLowerCase();
        activeFilter = activeFilter === label ? "all" : label;
        applyFilter(activeFilter);
      });
    });
  </script>
</body>
</html>
