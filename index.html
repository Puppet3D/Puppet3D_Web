<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>PPTest</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body class="settings-hidden">
  <!-- Auth Header -->
  <header class="auth-header" id="auth-header">
    <div class="auth-header__inner">
      <button type="button" class="auth-header__btn" id="auth-login-btn">Login</button>
      <div class="auth-header__account" id="auth-account-btn" style="display: none;">
        <span class="auth-header__email" id="auth-user-email">Account</span>
        <button type="button" class="auth-header__btn auth-header__btn--logout" id="auth-logout-btn">Logout</button>
      </div>
    </div>
  </header>

  <!-- Login Modal -->
  <div class="login-modal" id="login-modal">
    <div class="login-modal__content">
      <button type="button" class="login-modal__close" id="close-login-modal" aria-label="Close login modal">×</button>
      <h2 class="login-modal__title">Login to Puppet3D</h2>
      
      <div class="login-modal__error" id="auth-error-message"></div>

      <!-- Google Sign-In -->
      <button type="button" class="login-modal__btn login-modal__btn--google" id="google-login-btn">
        <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M17.64 9.20454C17.64 8.56636 17.5827 7.95272 17.4764 7.36363H9V10.845H13.8436C13.635 11.97 13.0009 12.9231 12.0477 13.5613V15.8195H14.9564C16.6582 14.2527 17.64 11.9454 17.64 9.20454Z" fill="#4285F4"/>
          <path d="M9 18C11.43 18 13.467 17.1941 14.9564 15.8195L12.0477 13.5613C11.2418 14.1013 10.2109 14.4204 9 14.4204C6.65454 14.4204 4.67181 12.8372 3.96409 10.71H0.957275V13.0418C2.43818 15.9831 5.48181 18 9 18Z" fill="#34A853"/>
          <path d="M3.96409 10.71C3.78409 10.17 3.68182 9.59318 3.68182 9C3.68182 8.40681 3.78409 7.83 3.96409 7.29V4.95818H0.957273C0.347727 6.17318 0 7.54772 0 9C0 10.4523 0.347727 11.8268 0.957273 13.0418L3.96409 10.71Z" fill="#FBBC05"/>
          <path d="M9 3.57955C10.3214 3.57955 11.5077 4.03364 12.4405 4.92545L15.0218 2.34409C13.4632 0.891818 11.4259 0 9 0C5.48182 0 2.43818 2.01682 0.957275 4.95818L3.96409 7.29C4.67182 5.16273 6.65454 3.57955 9 3.57955Z" fill="#EA4335"/>
        </svg>
        Continue with Google
      </button>

      <div class="login-modal__divider">
        <span>or</span>
      </div>

      <!-- Email/Password Forms -->
      <form class="login-modal__form" id="login-form">
        <div class="login-modal__field">
          <label for="email-input" class="login-modal__label">Email</label>
          <input type="email" id="email-input" class="login-modal__input" required autocomplete="email" />
        </div>
        <div class="login-modal__field">
          <label for="password-input" class="login-modal__label">Password</label>
          <input type="password" id="password-input" class="login-modal__input" required autocomplete="current-password" />
        </div>
        <button type="submit" class="login-modal__btn login-modal__btn--primary" id="email-submit-btn">Sign In</button>
        <p class="login-modal__switch">
          Don't have an account? <a href="#" id="signup-link">Sign up</a>
        </p>
      </form>

      <form class="login-modal__form" id="signup-form" style="display: none;">
        <div class="login-modal__field">
          <label for="signup-email-input" class="login-modal__label">Email</label>
          <input type="email" id="signup-email-input" class="login-modal__input" required autocomplete="email" />
        </div>
        <div class="login-modal__field">
          <label for="signup-password-input" class="login-modal__label">Password</label>
          <input type="password" id="signup-password-input" class="login-modal__input" required autocomplete="new-password" minlength="6" />
        </div>
        <button type="submit" class="login-modal__btn login-modal__btn--primary" id="signup-submit-btn">Sign Up</button>
        <p class="login-modal__switch">
          Already have an account? <a href="#" id="login-link">Sign in</a>
        </p>
      </form>
    </div>
  </div>
  
  <!-- Ancla visual del hero (punto de referencia del scroll automático) -->
  <div class="hero-anchor" id="hero-anchor" aria-hidden="true">
    <div class="hero-anchor__threshold hero-anchor__threshold--above"></div>
    <div class="hero-anchor__line"></div>
    <div class="hero-anchor__threshold hero-anchor__threshold--below"></div>
    <div class="hero-anchor__label">Hero Anchor</div>
  </div>
  
  <section class="hero-section" id="hero-section">
    <video class="hero-section__video" id="hero-video" src="videos/Hero.mp4" muted loop playsinline autoplay aria-hidden="true"></video>
    <div class="hero-section__overlay is-gradient" id="hero-overlay" aria-hidden="true"></div>
    <div class="hero-section__inner">
      <p class="hero-section__kicker">Featured</p>
      <h1 class="hero-section__headline">
        <span class="hero-section__headline-line">Puppet 3D</span>
      </h1>
      <p class="hero-section__subtitle">Making fun modeling in 3D</p>
      <div class="hero-section__ctas">
        <a href="#content" class="hero-section__cta hero-section__cta--primary">Ver proyectos</a>
        <a href="#" class="hero-section__cta hero-section__cta--secondary">Saber más</a>
      </div>
    </div>
  </section>

  <!-- Ancla visual de la galería (punto de referencia del scroll automático) -->
  <div class="gallery-anchor" id="gallery-anchor" aria-hidden="true">
    <div class="gallery-anchor__threshold gallery-anchor__threshold--above"></div>
    <div class="gallery-anchor__line"></div>
    <div class="gallery-anchor__threshold gallery-anchor__threshold--below"></div>
    <div class="gallery-anchor__label">Gallery Anchor</div>
  </div>

  <main class="page" id="content">
    <section class="grid">
      <article class="card c1" data-tags="ux" data-product-id="product-1">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>1 · Diseño UI + animaciones suaves</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="videos/Easy Assign Material.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>1 · Stack: HTML, CSS, JS. Enfoque en conversión y performance.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>

      <article class="card c2" data-tags="dev" data-product-id="product-2">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">Dev</span>
            <p>2 · Analítica en tiempo real</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">Dev</span>
              <p>2 · Componentes reutilizables y gráficos responsivos.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>

      <article class="card c3" data-tags="ux" data-product-id="product-3">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>3 · Checkout optimizado</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>3 · Mejora de UX y tasas de conversión.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>

      <article class="card c4" data-tags="dev" data-product-id="product-4">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">Dev</span>
            <p>4 · Interacciones micro-animadas</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">Dev</span>
              <p>4 · Prototipado rápido y pruebas con usuarios.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>

      <article class="card c5" data-tags="ux" data-product-id="product-5">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>5 · Wireframes y prototipos rápidos</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>5 · Iteración con feedback y pruebas A/B.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>

      <article class="card c1" data-tags="dev">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">Dev</span>
            <p>6 · Automatización y scripts internos</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">Dev</span>
              <p>6 · Herramientas para acelerar el flujo de trabajo.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>

      <article class="card c2" data-tags="ux">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>7 · Research y entrevistas a usuarios</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>7 · Hallazgos clave y recomendaciones.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>

      <article class="card c3" data-tags="dev">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">Dev</span>
            <p>8 · Integraciones con APIs externas</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">Dev</span>
              <p>8 · Conectores y sincronización de datos.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>

      <article class="card c4" data-tags="ux">
        <div class="card-inner">
          <div class="card-face card-front">
            <span class="card-tag">UX</span>
            <p>9 · Accesibilidad y mejoras de contraste</p>
          </div>
          <div class="card-face card-back">
            <div class="media">
              <video class="card-video" src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4" muted loop playsinline></video>
            </div>
            <div class="card-back-content">
              <span class="card-tag">UX</span>
              <p>9 · Auditoría y ajustes de accesibilidad.</p>
              <button type="button" class="cta buy-btn" style="display: none;">Buy</button>
            </div>
          </div>
        </div>
      </article>
    </section>
  </main>

  <aside class="hero-overlay-ui" aria-label="Overlay del Hero (video)">
    <h3 class="hero-overlay-ui__title">Hero overlay</h3>
    <label class="hero-overlay-ui__row">
      <span>Opacidad video</span>
      <input type="range" id="hero-video-opacity" min="0" max="100" value="100" />
      <output id="hero-video-opacity-out">100%</output>
    </label>
    <label class="hero-overlay-ui__row">
      <span>Ángulo video (°)</span>
      <input type="number" id="hero-video-mask-angle" value="0" min="0" max="360" />
    </label>
    <span class="hero-overlay-ui__label">Falloff video</span>
    <label class="hero-overlay-ui__row">
      <span>Inicio %</span>
      <input type="range" id="hero-video-falloff-start" min="0" max="100" value="0" />
      <output id="hero-video-falloff-start-out">0%</output>
    </label>
      <label class="hero-overlay-ui__row">
        <span>Fin %</span>
        <input type="range" id="hero-video-falloff-end" min="0" max="100" value="0" />
        <output id="hero-video-falloff-end-out">0%</output>
      </label>
      <label class="hero-overlay-ui__row hero-overlay-ui__row--checkbox">
        <span>Animar falloff con scroll</span>
        <input type="checkbox" id="hero-video-falloff-scroll" />
      </label>
    <label class="hero-overlay-ui__row">
      <span>Tipo</span>
      <select id="hero-overlay-type">
        <option value="solid">Sólido</option>
        <option value="gradient" selected>Gradiente</option>
      </select>
    </label>
    <div class="hero-overlay-ui__group">
      <span class="hero-overlay-ui__label">Color 1</span>
      <label class="hero-overlay-ui__row">
        <span>Hex</span>
        <input type="color" id="hero-overlay-color1" value="#24293e" />
      </label>
      <label class="hero-overlay-ui__row">
        <span>Opacidad</span>
        <input type="range" id="hero-overlay-opacity1" min="0" max="100" value="0" />
        <output id="hero-overlay-opacity1-out">0%</output>
      </label>
    </div>
    <div class="hero-overlay-ui__group hero-overlay-ui__group--gradient" id="hero-overlay-group2">
      <span class="hero-overlay-ui__label">Color 2 (gradiente)</span>
      <label class="hero-overlay-ui__row">
        <span>Hex</span>
        <input type="color" id="hero-overlay-color2" value="#24293e" />
      </label>
      <label class="hero-overlay-ui__row">
        <span>Opacidad</span>
        <input type="range" id="hero-overlay-opacity2" min="0" max="100" value="0" />
        <output id="hero-overlay-opacity2-out">0%</output>
      </label>
      <label class="hero-overlay-ui__row">
        <span>Ángulo (°)</span>
        <input type="number" id="hero-overlay-angle" value="160" min="0" max="360" />
      </label>
      <span class="hero-overlay-ui__label">Falloff</span>
      <label class="hero-overlay-ui__row">
        <span>Inicio %</span>
        <input type="range" id="hero-overlay-falloff-start" min="0" max="100" value="0" />
        <output id="hero-overlay-falloff-start-out">0%</output>
      </label>
      <label class="hero-overlay-ui__row">
        <span>Fin %</span>
        <input type="range" id="hero-overlay-falloff-end" min="0" max="100" value="60" />
        <output id="hero-overlay-falloff-end-out">60%</output>
      </label>
    </div>
    <div class="hero-overlay-ui__group">
      <span class="hero-overlay-ui__label">Botón Ver proyectos</span>
      <label class="hero-overlay-ui__row">
        <span>Fondo</span>
        <input type="color" id="hero-cta-primary-bg" value="#000000" />
      </label>
      <label class="hero-overlay-ui__row">
        <span>Contorno</span>
        <input type="color" id="hero-cta-primary-border" value="#e9c46a" />
      </label>
      <label class="hero-overlay-ui__row">
        <span>Grosor contorno (px)</span>
        <input type="number" id="hero-cta-primary-border-width" value="0" min="0" max="8" />
      </label>
      <label class="hero-overlay-ui__row">
        <span>Color letras</span>
        <input type="color" id="hero-cta-primary-color" value="#ffffff" />
      </label>
    </div>
  </aside>

  <div class="right-ui-stack">
  <aside class="collapsible-ui hero-text-position-ui" aria-label="Posición del texto del hero">
    <div class="collapsible-ui__header" tabindex="0" role="button" aria-expanded="true">
      <span class="collapsible-ui__title">Posición texto</span>
      <span class="collapsible-ui__toggle" aria-hidden="true">▼</span>
    </div>
    <div class="collapsible-ui__body">
    <label class="hero-text-position-ui__row">
      <span>Horizontal</span>
      <select id="hero-text-justify">
        <option value="flex-start">Izquierda</option>
        <option value="center" selected>Centro</option>
        <option value="flex-end">Derecha</option>
      </select>
    </label>
    <label class="hero-text-position-ui__row">
      <span>Vertical</span>
      <select id="hero-text-align-items">
        <option value="flex-start">Arriba</option>
        <option value="center" selected>Centro</option>
        <option value="flex-end">Abajo</option>
      </select>
    </label>
    <label class="hero-text-position-ui__row">
      <span>Alineación texto</span>
      <select id="hero-text-align">
        <option value="left">Izquierda</option>
        <option value="center" selected>Centro</option>
        <option value="right">Derecha</option>
      </select>
    </label>
    <label class="hero-text-position-ui__row">
      <span>Desplazar X (px)</span>
      <input type="number" id="hero-text-offset-x" value="0" />
    </label>
    <label class="hero-text-position-ui__row">
      <span>Desplazar Y (px)</span>
      <input type="number" id="hero-text-offset-y" value="160" />
    </label>
    </div>
  </aside>

  <aside class="collapsible-ui trigger-scroll-ui" aria-label="Disparador scroll automático">
    <div class="collapsible-ui__header" tabindex="0" role="button" aria-expanded="true">
      <span class="collapsible-ui__title">Disparador (scroll automático)</span>
      <span class="collapsible-ui__toggle" aria-hidden="true">▼</span>
    </div>
    <div class="collapsible-ui__body">
      <label class="trigger-scroll-ui__row trigger-scroll-ui__row--checkbox">
        <span>Activar</span>
        <input type="checkbox" id="kf-trigger-enable" checked />
      </label>
      <label class="trigger-scroll-ui__row" title="0% = inicio del hero">
        <span>Hero Anchor % (0 = inicio hero)</span>
        <input type="number" id="kf-trigger-hero-anchor" value="0" min="0" max="100" />
      </label>
      <label class="trigger-scroll-ui__row" title="Rango de threshold: si el viewport top sale de este rango (arriba o abajo), se dispara el scroll">
        <span>Threshold Gallery (px)</span>
        <input type="number" id="kf-trigger-threshold-px" value="250" />
      </label>
      <label class="trigger-scroll-ui__row" title="100% = inicio del grid (donde empieza el contenido)">
        <span>Gallery Anchor % (100 = inicio grid)</span>
        <input type="number" id="kf-trigger-target" value="100" min="0" max="100" />
      </label>
      <label class="trigger-scroll-ui__row trigger-scroll-ui__row--checkbox">
        <span>Inversa</span>
        <input type="checkbox" id="kf-trigger-inverse" checked />
      </label>
      <label class="trigger-scroll-ui__row" title="Rango de threshold: si el viewport top sale de este rango (arriba o abajo), se dispara el scroll inverso">
        <span>Threshold Hero (px)</span>
        <input type="number" id="kf-trigger-inverse-threshold-px" value="20" />
      </label>
    </div>
  </aside>

  <aside class="collapsible-ui scroll-range-ui" aria-label="Rango scroll animación">
    <div class="collapsible-ui__header" tabindex="0" role="button" aria-expanded="true">
      <span class="collapsible-ui__title">Rango scroll (animación)</span>
      <span class="collapsible-ui__toggle" aria-hidden="true">▼</span>
    </div>
    <div class="collapsible-ui__body">
      <label class="scroll-range-ui__row">
        <span>Desde %</span>
        <input type="number" id="kf-scroll-start" value="0" min="0" max="100" />
      </label>
      <label class="scroll-range-ui__row">
        <span>Hasta %</span>
        <input type="number" id="kf-scroll-end" value="100" min="0" max="100" />
      </label>
      <label class="scroll-range-ui__row">
        <span>Interpolación</span>
        <select id="kf-easing">
          <option value="linear">Linear</option>
          <option value="ease-in">Ease in</option>
          <option value="ease-out">Ease out</option>
          <option value="ease-in-out">Ease in-out</option>
          <option value="ease-in-cubic">Ease in (cúbico)</option>
          <option value="ease-out-cubic">Ease out (cúbico)</option>
          <option value="ease-in-out-cubic">Ease in-out (cúbico)</option>
        </select>
      </label>
    </div>
  </aside>

  <aside class="collapsible-ui keyframes-video-ui" aria-label="Keyframes falloff video">
    <div class="collapsible-ui__header" tabindex="0" role="button" aria-expanded="true">
      <span class="collapsible-ui__title">Keyframes video</span>
      <span class="collapsible-ui__toggle" aria-hidden="true">▼</span>
    </div>
    <div class="collapsible-ui__body">
    <div class="keyframes-video-ui__keyframe" data-kf-index="1">
      <span class="keyframes-video-ui__label">Keyframe 1</span>
      <label class="keyframes-video-ui__row">
        <span>Scroll %</span>
        <input type="number" id="kf1-scroll" value="0" min="0" max="100" />
      </label>
      <label class="keyframes-video-ui__row">
        <span>Inicio %</span>
        <input type="number" id="kf1-inicio" value="0" min="0" max="100" />
      </label>
      <label class="keyframes-video-ui__row">
        <span>Fin %</span>
        <input type="number" id="kf1-fin" value="20" min="0" max="100" />
      </label>
      <div class="keyframes-video-ui__btns">
        <button type="button" class="keyframes-video-ui__btn" data-kf-scroll="kf1-scroll">Ir a scroll</button>
        <button type="button" class="keyframes-video-ui__btn keyframes-video-ui__btn--danger" data-kf-delete="1">Borrar</button>
      </div>
    </div>
    <div class="keyframes-video-ui__keyframe" data-kf-index="2">
      <span class="keyframes-video-ui__label">Keyframe 2</span>
      <label class="keyframes-video-ui__row">
        <span>Scroll %</span>
        <input type="number" id="kf2-scroll" value="75" min="0" max="100" />
      </label>
      <label class="keyframes-video-ui__row">
        <span>Inicio %</span>
        <input type="number" id="kf2-inicio" value="80" min="0" max="100" />
      </label>
      <label class="keyframes-video-ui__row">
        <span>Fin %</span>
        <input type="number" id="kf2-fin" value="100" min="0" max="100" />
      </label>
      <div class="keyframes-video-ui__btns">
        <button type="button" class="keyframes-video-ui__btn" data-kf-scroll="kf2-scroll">Ir a scroll</button>
        <button type="button" class="keyframes-video-ui__btn keyframes-video-ui__btn--danger" data-kf-delete="2">Borrar</button>
      </div>
    </div>
    <div class="keyframes-video-ui__keyframe" data-kf-index="3">
      <span class="keyframes-video-ui__label">Keyframe 3</span>
      <label class="keyframes-video-ui__row">
        <span>Scroll %</span>
        <input type="number" id="kf3-scroll" value="100" min="0" max="100" />
      </label>
      <label class="keyframes-video-ui__row">
        <span>Inicio %</span>
        <input type="number" id="kf3-inicio" value="100" min="0" max="100" />
      </label>
      <label class="keyframes-video-ui__row">
        <span>Fin %</span>
        <input type="number" id="kf3-fin" value="100" min="0" max="100" />
      </label>
      <div class="keyframes-video-ui__btns">
        <button type="button" class="keyframes-video-ui__btn" data-kf-scroll="kf3-scroll">Ir a scroll</button>
        <button type="button" class="keyframes-video-ui__btn keyframes-video-ui__btn--danger" data-kf-delete="3">Borrar</button>
      </div>
    </div>
    </div>
  </aside>
  </div>

  <aside class="muppet-ui" aria-label="Ajustar espaciado de galería">
    <h3 class="muppet-ui__title">Gallery Spacing</h3>
    <label class="muppet-ui__row">
      <span>Offset Y (px)</span>
      <input type="number" id="gallery-offset-y" value="40" />
    </label>
    <label class="muppet-ui__row">
      <span>Gap cards (px)</span>
      <input type="number" id="grid-gap" value="25" min="0" />
    </label>
  </aside>

  <aside class="scroll-ui" aria-label="Diagnóstico de scroll">
    <h3 class="scroll-ui__title">Scroll Debug</h3>
    <div class="scroll-ui__row">
      <span>Ancho (px)</span>
      <output id="dbg-viewport-width">0</output>
    </div>
    <div class="scroll-ui__row">
      <span>Alto (px)</span>
      <output id="dbg-viewport-height">0</output>
    </div>
    <div class="scroll-ui__row">
      <span>Y (px)</span>
      <output id="dbg-scroll-y">0</output>
    </div>
    <div class="scroll-ui__row">
      <span>Página</span>
      <output id="dbg-page-progress">0%</output>
    </div>
    <div class="scroll-ui__row">
      <span>Hero</span>
      <output id="dbg-hero-progress">0%</output>
    </div>
    <div class="scroll-ui__row">
      <span>Rango hero</span>
      <output id="dbg-hero-range">0 - 0</output>
    </div>
    <div class="scroll-ui__row">
      <span>Cards top</span>
      <output id="dbg-content-top">0px</output>
    </div>
    <div class="scroll-ui__row">
      <span>Dirección</span>
      <output id="dbg-scroll-direction">idle</output>
    </div>
    <div class="scroll-ui__bar" aria-hidden="true">
      <span class="scroll-ui__bar-fill" id="dbg-page-bar"></span>
    </div>
  </aside>

  <button type="button" id="toggle-settings-ui" class="settings-toggle" aria-label="Mostrar u ocultar todos los paneles de ajustes" title="Mostrar / ocultar paneles">
    <span class="settings-toggle__label">UI</span>
  </button>

  <!-- Stripe SDK -->
  <script src="https://js.stripe.com/v3/"></script>
  
  <!-- Stripe Config (replace with your publishable key) -->
  <script src="stripe-config.js"></script>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  
  <!-- Firebase Config (replace with your credentials) -->
  <script src="firebase-config.js"></script>
  
  <!-- Auth Handler -->
  <script src="auth.js"></script>
  
  <!-- Stripe Checkout Handler -->
  <script src="stripe-checkout.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
  <script>
    (function stableViewportHeight() {
      var root = document.documentElement;
      var lastHeight = 0;

      function applyViewportHeight() {
        var h = Math.max(window.innerHeight || 0, 1);
        lastHeight = h;
        root.style.setProperty("--viewport-height", h + "px");
      }

      applyViewportHeight();

      // Orientation changes need a delayed re-read to avoid transient values.
      window.addEventListener("orientationchange", function () {
        setTimeout(applyViewportHeight, 180);
      });

      // Ignore tiny browser chrome changes; only apply on substantial resizes.
      window.addEventListener("resize", function () {
        var h = Math.max(window.innerHeight || 0, 1);
        if (Math.abs(h - lastHeight) > 140) {
          applyViewportHeight();
        }
      });
    })();

    (function toggleSettingsUI() {
      var btn = document.getElementById("toggle-settings-ui");
      if (btn) {
        btn.addEventListener("click", function () {
          document.body.classList.toggle("settings-hidden");
          btn.setAttribute("aria-pressed", document.body.classList.contains("settings-hidden") ? "true" : "false");
        });
        btn.setAttribute("aria-pressed", document.body.classList.contains("settings-hidden") ? "true" : "false");
      }
    })();

    (function collapsiblePanels() {
      document.querySelectorAll(".collapsible-ui__header").forEach(function (header) {
        var panel = header.closest(".collapsible-ui");
        if (!panel) return;
        function toggle() {
          panel.classList.toggle("is-collapsed");
          header.setAttribute("aria-expanded", panel.classList.contains("is-collapsed") ? "false" : "true");
        }
        header.addEventListener("click", toggle);
        header.addEventListener("keydown", function (e) {
          if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggle(); }
        });
      });
    })();

    (function muppetControls() {
      const root = document.documentElement;
      const galleryOffsetYInput = document.getElementById("gallery-offset-y");
      const gapInput = document.getElementById("grid-gap");
      function apply() {
        root.style.setProperty("--gallery-offset-y", (galleryOffsetYInput.value | 0) + "px");
        root.style.setProperty("--grid-gap", (gapInput.value | 0) + "px");
      }
      [galleryOffsetYInput, gapInput].forEach((el) => {
        el.addEventListener("input", apply);
        el.addEventListener("change", apply);
      });
      apply();
    })();

    (function heroOverlayControls() {
      var hexToRgb = function (hex) {
        var m = hex.replace(/^#/, "").match(/^([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i);
        return m ? m.slice(1).map(function (x) { return parseInt(x, 16); }).join(", ") : "26, 26, 46";
      };
      var heroSection = document.getElementById("hero-section");
      var overlay = document.getElementById("hero-overlay");
      var videoOpacityInput = document.getElementById("hero-video-opacity");
      var videoOpacityOut = document.getElementById("hero-video-opacity-out");
      var videoMaskAngleInput = document.getElementById("hero-video-mask-angle");
      var videoFalloffStart = document.getElementById("hero-video-falloff-start");
      var videoFalloffEnd = document.getElementById("hero-video-falloff-end");
      var videoFalloffStartOut = document.getElementById("hero-video-falloff-start-out");
      var videoFalloffEndOut = document.getElementById("hero-video-falloff-end-out");
      var typeSelect = document.getElementById("hero-overlay-type");
      var color1 = document.getElementById("hero-overlay-color1");
      var opacity1 = document.getElementById("hero-overlay-opacity1");
      var opacity1Out = document.getElementById("hero-overlay-opacity1-out");
      var color2 = document.getElementById("hero-overlay-color2");
      var opacity2 = document.getElementById("hero-overlay-opacity2");
      var opacity2Out = document.getElementById("hero-overlay-opacity2-out");
      var angleInput = document.getElementById("hero-overlay-angle");
      var group2 = document.getElementById("hero-overlay-group2");
      var falloffStart = document.getElementById("hero-overlay-falloff-start");
      var falloffEnd = document.getElementById("hero-overlay-falloff-end");
      var falloffStartOut = document.getElementById("hero-overlay-falloff-start-out");
      var falloffEndOut = document.getElementById("hero-overlay-falloff-end-out");
      var ctaPrimaryBg = document.getElementById("hero-cta-primary-bg");
      var ctaPrimaryBorder = document.getElementById("hero-cta-primary-border");
      var ctaPrimaryBorderWidth = document.getElementById("hero-cta-primary-border-width");
      var ctaPrimaryColor = document.getElementById("hero-cta-primary-color");
      var animateFalloffCheck = document.getElementById("hero-video-falloff-scroll");

      function apply() {
        if (!heroSection || !overlay) return;
        var isGradient = typeSelect ? typeSelect.value === "gradient" : false;
        var op1 = (opacity1.value | 0) / 100;
        var op2 = (opacity2.value | 0) / 100;
        var angle = (angleInput.value | 0) + "deg";
        var falloffStartVal = (falloffStart && falloffStart.value) ? (falloffStart.value | 0) : 0;
        var falloffEndVal = (falloffEnd && falloffEnd.value) ? (falloffEnd.value | 0) : 100;
        if (falloffEndVal < falloffStartVal) falloffEndVal = falloffStartVal;

        heroSection.style.setProperty("--hero-overlay-rgb1", hexToRgb(color1.value));
        heroSection.style.setProperty("--hero-overlay-op1", op1);
        heroSection.style.setProperty("--hero-overlay-rgb2", hexToRgb(color2.value));
        heroSection.style.setProperty("--hero-overlay-op2", op2);
        heroSection.style.setProperty("--hero-overlay-angle", angle);
        heroSection.style.setProperty("--hero-overlay-falloff-start", falloffStartVal + "%");
        heroSection.style.setProperty("--hero-overlay-falloff-end", falloffEndVal + "%");
        var videoOp = (videoOpacityInput && videoOpacityInput.value) ? (videoOpacityInput.value | 0) / 100 : 1;
        heroSection.style.setProperty("--hero-video-opacity", videoOp);
        var videoMaskAngle = (videoMaskAngleInput && videoMaskAngleInput.value) ? (videoMaskAngleInput.value | 0) + "deg" : "160deg";
        heroSection.style.setProperty("--hero-video-mask-angle", videoMaskAngle);
        var animateFalloffWithScroll = animateFalloffCheck && animateFalloffCheck.checked;
        if (!animateFalloffWithScroll) {
          var videoFalloffStartVal = (videoFalloffStart && videoFalloffStart.value) ? (videoFalloffStart.value | 0) : 0;
          var videoFalloffEndVal = (videoFalloffEnd && videoFalloffEnd.value) ? (videoFalloffEnd.value | 0) : 60;
          if (videoFalloffEndVal < videoFalloffStartVal) videoFalloffEndVal = videoFalloffStartVal;
          heroSection.style.setProperty("--hero-video-falloff-start", videoFalloffStartVal + "%");
          heroSection.style.setProperty("--hero-video-falloff-end", videoFalloffEndVal + "%");
        }
        if (ctaPrimaryBg) heroSection.style.setProperty("--hero-cta-primary-bg", ctaPrimaryBg.value);
        if (ctaPrimaryBorder) heroSection.style.setProperty("--hero-cta-primary-border", ctaPrimaryBorder.value);
        if (ctaPrimaryBorderWidth) heroSection.style.setProperty("--hero-cta-primary-border-width", (ctaPrimaryBorderWidth.value | 0) + "px");
        if (ctaPrimaryColor) heroSection.style.setProperty("--hero-cta-primary-color", ctaPrimaryColor.value);
        overlay.classList.toggle("is-gradient", isGradient);
        if (group2) group2.style.display = isGradient ? "block" : "none";
      }

      function updateOutputs() {
        if (videoOpacityOut) videoOpacityOut.textContent = (videoOpacityInput ? videoOpacityInput.value | 0 : 100) + "%";
        if (opacity1Out) opacity1Out.textContent = (opacity1.value | 0) + "%";
        if (opacity2Out) opacity2Out.textContent = (opacity2.value | 0) + "%";
        if (falloffStartOut) falloffStartOut.textContent = (falloffStart ? falloffStart.value | 0 : 0) + "%";
        if (falloffEndOut) falloffEndOut.textContent = (falloffEnd ? falloffEnd.value | 0 : 100) + "%";
        if (videoFalloffStartOut) videoFalloffStartOut.textContent = (videoFalloffStart ? videoFalloffStart.value | 0 : 0) + "%";
        if (videoFalloffEndOut) videoFalloffEndOut.textContent = (videoFalloffEnd ? videoFalloffEnd.value | 0 : 60) + "%";
      }

      [videoOpacityInput, videoMaskAngleInput, videoFalloffStart, videoFalloffEnd, animateFalloffCheck, typeSelect, color1, opacity1, color2, opacity2, angleInput, falloffStart, falloffEnd, ctaPrimaryBg, ctaPrimaryBorder, ctaPrimaryBorderWidth, ctaPrimaryColor].forEach(function (el) {
        if (!el) return;
        el.addEventListener("input", function () {
          if (window.__updatingVideoFalloffFromScroll) return;
          apply();
          updateOutputs();
        });
        el.addEventListener("change", function () {
          if (window.__updatingVideoFalloffFromScroll) return;
          apply();
          updateOutputs();
        });
      });
      apply();
      updateOutputs();
    })();

    (function heroTextPositionControls() {
      var heroSection = document.getElementById("hero-section");
      var justifySelect = document.getElementById("hero-text-justify");
      var alignItemsSelect = document.getElementById("hero-text-align-items");
      var textAlignSelect = document.getElementById("hero-text-align");
      var offsetX = document.getElementById("hero-text-offset-x");
      var offsetY = document.getElementById("hero-text-offset-y");

      function apply() {
        if (!heroSection) return;
        heroSection.style.setProperty("--hero-justify-content", justifySelect ? justifySelect.value : "center");
        heroSection.style.setProperty("--hero-align-items", alignItemsSelect ? alignItemsSelect.value : "center");
        heroSection.style.setProperty("--hero-text-align", textAlignSelect ? textAlignSelect.value : "center");
        heroSection.style.setProperty("--hero-text-offset-x", (offsetX && offsetX.value !== "" ? (offsetX.value | 0) : 0) + "px");
        heroSection.style.setProperty("--hero-text-offset-y", (offsetY && offsetY.value !== "" ? (offsetY.value | 0) : 0) + "px");
      }

      [justifySelect, alignItemsSelect, textAlignSelect, offsetX, offsetY].forEach(function (el) {
        if (!el) return;
        el.addEventListener("input", apply);
        el.addEventListener("change", apply);
      });
      apply();
    })();

    (function heroSection() {
      if (typeof gsap === "undefined") return;
      if (typeof ScrollTrigger !== "undefined") gsap.registerPlugin(ScrollTrigger);

      const hero = document.getElementById("hero-section");
      const headlineLines = document.querySelectorAll(".hero-section__headline-line");
      const kicker = document.querySelector(".hero-section__kicker");
      const subtitle = document.querySelector(".hero-section__subtitle");
      const ctas = document.querySelector(".hero-section__ctas");
      const content = document.getElementById("content");
      const dbgViewportWidth = document.getElementById("dbg-viewport-width");
      const dbgViewportHeight = document.getElementById("dbg-viewport-height");
      const dbgScrollY = document.getElementById("dbg-scroll-y");
      const dbgPageProgress = document.getElementById("dbg-page-progress");
      const dbgHeroProgress = document.getElementById("dbg-hero-progress");
      const dbgHeroRange = document.getElementById("dbg-hero-range");
      const dbgContentTop = document.getElementById("dbg-content-top");
      const dbgDirection = document.getElementById("dbg-scroll-direction");
      const dbgPageBar = document.getElementById("dbg-page-bar");

      if (!hero) return;

      const heroVideo = document.getElementById("hero-video");
      if (heroVideo) {
        heroVideo.play().catch(() => {});
        document.body.addEventListener("click", function startHeroVideo() {
          heroVideo.play().catch(() => {});
          document.body.removeEventListener("click", startHeroVideo);
        }, { once: true });
      }

      const getScrollDistance = () => Math.max(window.innerHeight, 1);
      let lastScrollY = Math.round(window.scrollY || 0);
      let lastHeroProgress = Math.min(
        1,
        Math.max(0, lastScrollY / Math.max(getScrollDistance(), 1))
      );
      let triggerArmed = true;
      let inverseArmed = false;
      let wasInGalleryThreshold = false;
      let wasInHeroThreshold = false;
      let isAutoScrolling = false; // Flag para prevenir múltiples disparos
      let autoScrollTargetY = null;

      const toPct = (value) => `${Math.round(value * 100)}%`;
      const setText = (el, value) => {
        if (el) el.textContent = value;
      };
      const updateScrollDebug = () => {
        const scrollY = Math.round(window.scrollY || 0);
        const maxScroll = Math.max(
          document.documentElement.scrollHeight - window.innerHeight,
          1
        );
        const pageProgress = Math.min(1, Math.max(0, scrollY / maxScroll));
        const heroStart = 0;
        const heroEnd = Math.round(getScrollDistance());
        const heroProgress = Math.min(
          1,
          Math.max(0, (scrollY - heroStart) / Math.max(heroEnd - heroStart, 1))
        );
        let direction = "idle";
        if (scrollY > lastScrollY) direction = "down";
        else if (scrollY < lastScrollY) direction = "up";

        const triggerCheck = document.getElementById("kf-trigger-enable");
        const thresholdPxEl = document.getElementById("kf-trigger-threshold-px");
        const targetEl = document.getElementById("kf-trigger-target");
        const heroAnchorEl = document.getElementById("kf-trigger-hero-anchor");
        const galleryAnchor = document.getElementById("gallery-anchor");
        const heroAnchor = document.getElementById("hero-anchor");
        
        // Update hero anchor position (independent of trigger state)
        let heroAnchorPosition = 0;
        if (heroAnchorEl && heroAnchor) {
          const heroAnchorRaw = parseFloat(heroAnchorEl.value);
          const heroAnchorPct =
            Math.max(0, Math.min(100, Number.isFinite(heroAnchorRaw) ? heroAnchorRaw : 0)) / 100;
          heroAnchorPosition = heroAnchorPct * heroEnd;
          heroAnchor.style.top = `${heroAnchorPosition}px`;
        }
        
        if (triggerCheck && triggerCheck.checked && thresholdPxEl && targetEl && heroAnchor) {
          const thresholdPx = parseFloat(thresholdPxEl.value);
          const thresholdPxValue = Number.isFinite(thresholdPx) ? thresholdPx : 50;
          const targetRaw = parseFloat(targetEl.value);
          const targetPct =
            Math.max(0, Math.min(100, Number.isFinite(targetRaw) ? targetRaw : 100)) / 100;

          // Update hero threshold lines (IDA: hero -> gallery)
          const heroThresholdAbove = heroAnchor.querySelector('.hero-anchor__threshold--above');
          const heroThresholdBelow = heroAnchor.querySelector('.hero-anchor__threshold--below');
          if (heroThresholdAbove) {
            heroThresholdAbove.style.bottom = `${thresholdPxValue}px`;
          }
          if (heroThresholdBelow) {
            heroThresholdBelow.style.top = `${thresholdPxValue}px`;
          }

          // Update gallery anchor position (destination)
          const galleryAnchorPosition = targetPct * heroEnd;
          if (galleryAnchor) {
            galleryAnchor.style.top = `${galleryAnchorPosition}px`;
          }

          // IDA: el trigger se evalua saliendo del rango del HERO anchor
          const viewportTop = window.scrollY;
          const thresholdTop = heroAnchorPosition - thresholdPxValue;
          const thresholdBottom = heroAnchorPosition + thresholdPxValue;

          // Check if viewport top is currently within the threshold range
          const isInThreshold = viewportTop >= thresholdTop && viewportTop <= thresholdBottom;

          // No evaluar triggers mientras corre un auto-scroll.
          // Se libera cuando llegamos al target real guardado.
          if (isAutoScrolling) {
            const targetScroll = typeof autoScrollTargetY === "number"
              ? autoScrollTargetY
              : Math.round(targetPct * heroEnd);
            const scrollDiff = Math.abs(viewportTop - targetScroll);
            if (scrollDiff < 6) {
              isAutoScrolling = false;
              autoScrollTargetY = null;
              triggerArmed = true;
              inverseArmed = true;
              wasInGalleryThreshold = false;
              wasInHeroThreshold = false;
            }
            return; // evitar re-disparos durante animacion
          }

          // Reset trigger if viewport top is within the threshold range
          if (isInThreshold) {
            triggerArmed = true;
            wasInGalleryThreshold = true;
          } else {
            // Solo dispara al salir por abajo del rango del hero (scroll hacia abajo)
            if (wasInGalleryThreshold && direction === "down" && viewportTop > thresholdBottom && triggerArmed) {
              triggerArmed = false;
              wasInGalleryThreshold = false;
              isAutoScrolling = true; // Marcar que estamos en scroll automático
              const targetScroll = Math.round(targetPct * heroEnd);
              autoScrollTargetY = targetScroll;
              
              // Usar requestAnimationFrame para asegurar que el scroll sea preciso
              requestAnimationFrame(() => {
                window.scrollTo({ top: targetScroll, behavior: "smooth" });
              });
            } else if (!isInThreshold) {
              // We're outside, but weren't inside before, so reset the flag
              wasInGalleryThreshold = false;
            }
          }
        } else {
          triggerArmed = true;
          // Show anchors at default positions even if trigger is disabled
          if (galleryAnchor) {
            galleryAnchor.style.display = 'block';
            galleryAnchor.style.top = `${heroEnd}px`;
          }
          if (heroAnchor && heroAnchorEl) {
            const heroAnchorRaw = parseFloat(heroAnchorEl.value);
            const heroAnchorPct =
              Math.max(0, Math.min(100, Number.isFinite(heroAnchorRaw) ? heroAnchorRaw : 0)) / 100;
            const heroAnchorPosition = heroAnchorPct * heroEnd;
            heroAnchor.style.top = `${heroAnchorPosition}px`;
          }
        }

        const inverseCheck = document.getElementById("kf-trigger-inverse");
        const inverseThresholdPxEl = document.getElementById("kf-trigger-inverse-threshold-px");
        if (inverseCheck && inverseCheck.checked && inverseThresholdPxEl && heroAnchorEl) {
          const inverseThresholdPx = parseFloat(inverseThresholdPxEl.value);
          const inverseThresholdPxValue = Number.isFinite(inverseThresholdPx) ? inverseThresholdPx : 20;
          
          // VUELTA: usa rango del GALLERY anchor y vuelve al hero anchor
          const targetRaw = parseFloat(targetEl ? targetEl.value : "100");
          const targetPct =
            Math.max(0, Math.min(100, Number.isFinite(targetRaw) ? targetRaw : 100)) / 100;
          const galleryAnchorPosition = targetPct * heroEnd;
          const gobackScroll = Math.round(heroAnchorPosition);

          if (galleryAnchor) {
            const thresholdAbove = galleryAnchor.querySelector('.gallery-anchor__threshold--above');
            const thresholdBelow = galleryAnchor.querySelector('.gallery-anchor__threshold--below');
            if (thresholdAbove) {
              thresholdAbove.style.bottom = `${inverseThresholdPxValue}px`;
            }
            if (thresholdBelow) {
              thresholdBelow.style.top = `${inverseThresholdPxValue}px`;
            }
          }

          const viewportTop = window.scrollY;
          const thresholdTop = galleryAnchorPosition - inverseThresholdPxValue;
          const thresholdBottom = galleryAnchorPosition + inverseThresholdPxValue;

          // Check if viewport top is currently within the threshold range
          const isInThreshold = viewportTop >= thresholdTop && viewportTop <= thresholdBottom;

          // No evaluar trigger si ya estamos haciendo scroll automático
          if (isAutoScrolling) {
            // Verificar si el scroll automático ha terminado (estamos cerca del target)
            const scrollDiff = Math.abs(viewportTop - gobackScroll);
            if (scrollDiff < 5) {
              // Hemos llegado al destino, resetear flag
              isAutoScrolling = false;
              inverseArmed = true;
              wasInHeroThreshold = false;
            }
            return; // Salir temprano si estamos en scroll automático
          }

          // Reset trigger if viewport top is within the threshold range
          if (isInThreshold) {
            inverseArmed = true;
            wasInHeroThreshold = true;
          } else {
            // Solo dispara al salir por arriba del rango de gallery (scroll hacia arriba)
            if (wasInHeroThreshold && direction === "up" && viewportTop < thresholdTop && inverseArmed) {
              inverseArmed = false;
              wasInHeroThreshold = false;
              isAutoScrolling = true; // Marcar que estamos en scroll automático
              autoScrollTargetY = gobackScroll;
              
              // Usar requestAnimationFrame para asegurar que el scroll sea preciso
              requestAnimationFrame(() => {
                window.scrollTo({ top: gobackScroll, behavior: "smooth" });
              });
            } else if (!isInThreshold) {
              // We're outside, but weren't inside before, so reset the flag
              wasInHeroThreshold = false;
            }
          }
        } else {
          inverseArmed = false;
        }
        const contentTop = content
          ? Math.round(content.getBoundingClientRect().top)
          : 0;

        const animateFalloffCheck = document.getElementById("hero-video-falloff-scroll");
        if (hero && animateFalloffCheck && animateFalloffCheck.checked) {
          var easingFns = {
            linear: function (t) { return t; },
            "ease-in": function (t) { return t * t; },
            "ease-out": function (t) { return t * (2 - t); },
            "ease-in-out": function (t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },
            "ease-in-cubic": function (t) { return t * t * t; },
            "ease-out-cubic": function (t) { return 1 - Math.pow(1 - t, 3); },
            "ease-in-out-cubic": function (t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
          };
          var easeSelect = document.getElementById("kf-easing");
          var easeName = (easeSelect && easeSelect.value) ? easeSelect.value : "linear";
          var easeFn = easingFns[easeName] || easingFns.linear;
          var getVal = function (id) { var el = document.getElementById(id); return el && el.value !== "" ? parseFloat(el.value) : 0; };
          var keyframes = [];
          [1, 2, 3].forEach(function (idx) {
            var scrollEl = document.getElementById("kf" + idx + "-scroll");
            if (scrollEl && document.body.contains(scrollEl)) {
              keyframes.push({
                s: getVal("kf" + idx + "-scroll") / 100,
                i: getVal("kf" + idx + "-inicio"),
                f: getVal("kf" + idx + "-fin")
              });
            }
          });
          keyframes.sort(function (a, b) { return a.s - b.s; });
          var scrollStartPct = getVal("kf-scroll-start") / 100;
          var scrollEndPct = getVal("kf-scroll-end") / 100;
          if (scrollEndPct <= scrollStartPct) scrollEndPct = scrollStartPct + 0.01;
          var animProgress = heroProgress <= scrollStartPct ? 0 : (heroProgress >= scrollEndPct ? 1 : (heroProgress - scrollStartPct) / (scrollEndPct - scrollStartPct));
          var videoInicio, videoFin;
          if (keyframes.length === 0) {
            videoInicio = 0;
            videoFin = 80;
          } else if (keyframes.length === 1) {
            videoInicio = keyframes[0].i;
            videoFin = keyframes[0].f;
          } else {
            if (animProgress <= keyframes[0].s) {
              videoInicio = keyframes[0].i;
              videoFin = keyframes[0].f;
            } else if (animProgress >= keyframes[keyframes.length - 1].s) {
              videoInicio = keyframes[keyframes.length - 1].i;
              videoFin = keyframes[keyframes.length - 1].f;
            } else {
              var seg = 0;
              for (var i = 0; i < keyframes.length - 1; i++) {
                if (animProgress >= keyframes[i].s && animProgress <= keyframes[i + 1].s) { seg = i; break; }
              }
              var k0 = keyframes[seg];
              var k1 = keyframes[seg + 1];
              var den = k1.s - k0.s;
              var t = (den > 1e-6) ? Math.max(0, Math.min(1, (animProgress - k0.s) / den)) : 1;
              var te = easeFn(t);
              videoInicio = Math.round(k0.i + (k1.i - k0.i) * te);
              videoFin = Math.round(k0.f + (k1.f - k0.f) * te);
            }
          }
          hero.style.setProperty("--hero-video-falloff-start", videoInicio + "%");
          hero.style.setProperty("--hero-video-falloff-end", videoFin + "%");
          window.__updatingVideoFalloffFromScroll = true;
          var vfStartEl = document.getElementById("hero-video-falloff-start");
          var vfEndEl = document.getElementById("hero-video-falloff-end");
          var vfStartOut = document.getElementById("hero-video-falloff-start-out");
          var vfEndOut = document.getElementById("hero-video-falloff-end-out");
          if (vfStartEl) vfStartEl.value = videoInicio;
          if (vfEndEl) vfEndEl.value = videoFin;
          if (vfStartOut) vfStartOut.textContent = videoInicio + "%";
          if (vfEndOut) vfEndOut.textContent = videoFin + "%";
          window.__updatingVideoFalloffFromScroll = false;
        }

        setText(dbgViewportWidth, String(window.innerWidth));
        setText(dbgViewportHeight, String(window.innerHeight));
        setText(dbgScrollY, String(scrollY));
        setText(dbgPageProgress, toPct(pageProgress));
        setText(dbgHeroProgress, toPct(heroProgress));
        setText(dbgHeroRange, `${heroStart} - ${heroEnd}`);
        setText(dbgContentTop, `${contentTop}px`);
        setText(dbgDirection, direction);
        if (dbgPageBar) dbgPageBar.style.width = `${Math.round(pageProgress * 100)}%`;

        lastScrollY = scrollY;
        lastHeroProgress = heroProgress;
      };

      const tl = gsap.timeline({ defaults: { ease: "power3.out" } });
      tl.set(hero, { opacity: 1 })
        .fromTo(kicker, { opacity: 0, y: 12 }, { opacity: 1, y: 0, duration: 0.6 })
        .fromTo(
          headlineLines,
          { opacity: 0, y: "1.2em" },
          { opacity: 1, y: 0, duration: 0.7, stagger: 0.12, delay: 0.1 }
        )
        .fromTo(
          subtitle,
          { opacity: 0, y: 16 },
          { opacity: 1, y: 0, duration: 0.6 },
          "-=0.3"
        )
        .fromTo(ctas, { opacity: 0, y: 16 }, { opacity: 1, y: 0, duration: 0.5 }, "-=0.4");

      window.addEventListener("scroll", updateScrollDebug, { passive: true });
      window.addEventListener("resize", updateScrollDebug);
      if (typeof ScrollTrigger !== "undefined") {
        ScrollTrigger.addEventListener("refresh", updateScrollDebug);
      }
      
      // Update anchors when inputs change
      const targetEl = document.getElementById("kf-trigger-target");
      const heroAnchorEl = document.getElementById("kf-trigger-hero-anchor");
      const thresholdPxEl = document.getElementById("kf-trigger-threshold-px");
      const inverseThresholdPxEl = document.getElementById("kf-trigger-inverse-threshold-px");
      
      if (targetEl) {
        targetEl.addEventListener("input", updateScrollDebug);
        targetEl.addEventListener("change", updateScrollDebug);
      }
      if (heroAnchorEl) {
        heroAnchorEl.addEventListener("input", updateScrollDebug);
        heroAnchorEl.addEventListener("change", updateScrollDebug);
      }
      if (thresholdPxEl) {
        thresholdPxEl.addEventListener("input", updateScrollDebug);
        thresholdPxEl.addEventListener("change", updateScrollDebug);
      }
      if (inverseThresholdPxEl) {
        inverseThresholdPxEl.addEventListener("input", updateScrollDebug);
        inverseThresholdPxEl.addEventListener("change", updateScrollDebug);
      }
      
      updateScrollDebug();
    })();

    (function keyframesVideoLive() {
      var ids = ["kf-easing", "kf-scroll-start", "kf-scroll-end", "kf1-scroll", "kf1-inicio", "kf1-fin", "kf2-scroll", "kf2-inicio", "kf2-fin", "kf3-scroll", "kf3-inicio", "kf3-fin"];
      function triggerFalloffUpdate() {
        window.dispatchEvent(new Event("scroll"));
      }
      ids.forEach(function (id) {
        var el = document.getElementById(id);
        if (el) {
          el.addEventListener("input", triggerFalloffUpdate);
          el.addEventListener("change", triggerFalloffUpdate);
        }
      });
      var heroEnd = function () { return Math.max(window.innerHeight, 1); };
      document.querySelectorAll(".keyframes-video-ui__btn[data-kf-scroll]").forEach(function (btn) {
        btn.addEventListener("click", function () {
          var inputId = btn.getAttribute("data-kf-scroll");
          var input = inputId ? document.getElementById(inputId) : null;
          if (!input) return;
          var pct = parseFloat(input.value);
          if (Number.isNaN(pct)) return;
          var target = (Math.max(0, Math.min(100, pct)) / 100) * heroEnd();
          window.scrollTo({ top: target, behavior: "smooth" });
        });
      });
      document.querySelectorAll(".keyframes-video-ui__btn[data-kf-delete]").forEach(function (btn) {
        btn.addEventListener("click", function () {
          var index = btn.getAttribute("data-kf-delete");
          var block = document.querySelector(".keyframes-video-ui__keyframe[data-kf-index=\"" + index + "\"]");
          if (block && block.parentNode) {
            block.parentNode.removeChild(block);
            window.dispatchEvent(new Event("scroll"));
          }
        });
      });
    })();

    const cards = Array.from(document.querySelectorAll(".card"));

    let expandedCard = null;

    cards.forEach((card) => {
      const video = card.querySelector(".card-video");
      if (!video) return;

      card.addEventListener("mouseenter", () => {
        video.currentTime = 0;
        video.play().catch(() => {});
      });

      card.addEventListener("mouseleave", () => {
        if (card.classList.contains("is-expanded")) return;
        if (expandedCard === card) return;
        video.pause();
      });
    });

    const expandDuration = 700;
    const expandEasing = "cubic-bezier(0.2, 0.7, 0.2, 1)";

    const makeCubicBezier = (p1x, p1y, p2x, p2y) => {
      const cx = 3 * p1x;
      const bx = 3 * (p2x - p1x) - cx;
      const ax = 1 - cx - bx;
      const cy = 3 * p1y;
      const by = 3 * (p2y - p1y) - cy;
      const ay = 1 - cy - by;

      const sampleX = (t) => ((ax * t + bx) * t + cx) * t;
      const sampleY = (t) => ((ay * t + by) * t + cy) * t;
      const sampleDerivX = (t) => (3 * ax * t + 2 * bx) * t + cx;

      return (x) => {
        let t = x;
        for (let i = 0; i < 6; i += 1) {
          const dx = sampleX(t) - x;
          const d = sampleDerivX(t);
          if (Math.abs(dx) < 1e-5 || Math.abs(d) < 1e-5) break;
          t -= dx / d;
        }
        return sampleY(t);
      };
    };

    const easeExpand = makeCubicBezier(0.2, 0.7, 0.2, 1);

    const centerCardInView = (card) => {
      const getTarget = () => {
        const rect = card.getBoundingClientRect();
        const targetY =
          window.scrollY + rect.top + rect.height / 2 - window.innerHeight / 2;
        const maxScroll =
          document.documentElement.scrollHeight - window.innerHeight;
        return Math.max(0, Math.min(targetY, maxScroll));
      };

      const startTime = performance.now();
      const tick = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / expandDuration, 1);
        const eased = easeExpand(t);
        const target = getTarget();
        const current = window.scrollY;
        window.scrollTo(0, current + (target - current) * eased);
        if (t < 1) {
          requestAnimationFrame(tick);
        }
      };

      requestAnimationFrame(tick);
    };

    const animateReflow = () => {
      if (reduceMotion) return;
      const firstRects = new Map();
      cards.forEach((card) => firstRects.set(card, card.getBoundingClientRect()));
      requestAnimationFrame(() => {
        cards.forEach((card) => {
          const first = firstRects.get(card);
          const last = card.getBoundingClientRect();
          if (!first) return;
          const dx = first.left - last.left;
          const dy = first.top - last.top;
          if (dx || dy) {
            card.animate(
              [
                { transform: `translate(${dx}px, ${dy}px)` },
                { transform: "translate(0, 0)" },
              ],
              { duration: expandDuration, easing: expandEasing }
            );
          }
        });
      });
    };

    const renderMissingSlots = (missingSlots, cols, gridRect, cellSize, gap) => {
      const grid = document.querySelector(".grid");
      const existing = Array.from(grid.querySelectorAll(".missing-slot"));
      if (!missingSlots.length) {
        existing.forEach((el) => {
          el.classList.add("missing-leave");
          setTimeout(() => el.remove(), 250);
        });
        return;
      }
      existing.forEach((el) => el.remove());
      missingSlots.forEach((slot) => {
        const row = Math.ceil(slot / cols);
        const col = slot - (row - 1) * cols;
        const placeholder = document.createElement("div");
        placeholder.className = "card missing-slot";
        const top = (row - 1) * (cellSize + gap);
        const left = (col - 1) * (cellSize + gap);
        placeholder.style.position = "absolute";
        placeholder.style.top = `${top}px`;
        placeholder.style.left = `${left}px`;
        placeholder.style.width = `${cellSize}px`;
        placeholder.style.height = `${cellSize}px`;
        placeholder.innerHTML = `<div class="missing-label">Hueco ${slot}</div>`;
        grid.appendChild(placeholder);
        requestAnimationFrame(() => placeholder.classList.add("is-visible"));
      });
    };

    const clearMissingSlotsImmediate = () => {
      const grid = document.querySelector(".grid");
      const existing = Array.from(grid.querySelectorAll(".missing-slot"));
      existing.forEach((el) => {
        el.classList.add("missing-leave");
        setTimeout(() => el.remove(), 250);
      });
    };

    const updateCardPositions = (logMissing = false, renderMissing = false) => {
      if (typeof log === "function") log("11a. updateCardPositions inicio");
      const grid = document.querySelector(".grid");
      const gridStyle = getComputedStyle(grid);
      const gap = parseFloat(gridStyle.gap) || 0;
      const columns = gridStyle.gridTemplateColumns.split(" ");
      const cols = columns.length;
      const gridRect = grid.getBoundingClientRect();
      const cellSize =
        cols > 0 ? (gridRect.width - gap * (cols - 1)) / cols : 0;
      const cellStep = cellSize + gap;

      const slotMap = new Map();
      cards.forEach((card) => slotMap.set(card, []));

      cards.forEach((card) => {
        const rect = card.getBoundingClientRect();
        const col = Math.max(
          1,
          Math.floor((rect.left - gridRect.left + 1) / cellStep) + 1
        );
        const row = Math.max(
          1,
          Math.floor((rect.top - gridRect.top + 1) / cellStep) + 1
        );
        const colSpan = Math.max(
          1,
          Math.round((rect.width + gap) / cellStep)
        );
        const rowSpan = Math.max(
          1,
          Math.round((rect.height + gap) / cellStep)
        );

        const slots = [];
        for (let r = row; r < row + rowSpan; r += 1) {
          for (let c = col; c < col + colSpan; c += 1) {
            slots.push((r - 1) * cols + c);
          }
        }
        slotMap.set(card, slots);
      });

      cards.forEach((card) => {
        const label = slotMap.get(card).join(", ");
        card.querySelectorAll(".card-front p").forEach((p) => {
          const text = p.textContent.replace(/^\d+(,\s*\d+)*\s·\s/, "");
          p.textContent = `${label} · ${text}`;
        });
        card.querySelectorAll(".card-back-content p").forEach((p) => {
          const text = p.textContent.replace(/^\d+(,\s*\d+)*\s·\s/, "");
          p.textContent = `${label} · ${text}`;
        });
      });

      const expanded = document.querySelector(".card.is-expanded");
      if (expanded && renderMissing) {
        let maxSlot = 0;
        slotMap.forEach((slots) => {
          slots.forEach((slot) => {
            if (slot > maxSlot) maxSlot = slot;
          });
        });
        const totalSlots = maxSlot;
        const used = new Set();
        slotMap.forEach((slots) => slots.forEach((slot) => used.add(slot)));
        const missing = [];
        for (let i = 1; i <= totalSlots; i += 1) {
          if (!used.has(i)) missing.push(i);
        }
        renderMissingSlots(missing, cols, gridRect, cellSize, gap);
        if (logMissing) {
          console.log(
            "Slots faltantes:",
            missing.length ? missing.join(", ") : "ninguno"
          );
        }
      } else if (!expanded) {
        renderMissingSlots([], cols, gridRect, cellSize, gap);
      }
      if (typeof log === "function") log("11b. updateCardPositions fin");
    };

    let expandRunId = 0;

    const finalizeMissingSlots = (runId) => {
      log("9. finalizeMissingSlots llamado runId=", runId);
      setTimeout(() => {
        if (runId !== expandRunId) {
          log("10. finalizeMissingSlots ignorado (runId distinto)");
          return;
        }
        log("11. updateCardPositions(true, true)");
        updateCardPositions(true, true);
      }, 0);
    };

    const DEBUG_EXPAND = true; // poner false para quitar logs
    const log = (...args) => DEBUG_EXPAND && console.log("[expand]", ...args);

    const toggleExpand = (card) => {
      log("1. toggleExpand inicio");
      clearMissingSlotsImmediate();
      cards.forEach((c) => {
        c.getAnimations().forEach((a) => a.cancel());
      });
      expandRunId += 1;
      const runId = expandRunId;
      const firstRects = new Map();
      const grid = document.querySelector(".grid");
      const gridCenterX = grid.getBoundingClientRect().left + grid.getBoundingClientRect().width / 2;
      const rowTops = [];
      if (!reduceMotion) {
        cards.forEach((c) => firstRects.set(c, c.getBoundingClientRect()));
      }
      cards.forEach((c) => {
        const rect = firstRects.get(c) || c.getBoundingClientRect();
        const top = Math.round(rect.top);
        const match = rowTops.find((t) => Math.abs(t - top) < 2);
        if (match === undefined) {
          rowTops.push(top);
        }
      });
      rowTops.sort((a, b) => a - b);

      const isExpanded = card.classList.contains("is-expanded");
      log("2. isExpanded=", isExpanded, "runId=", runId);
      document
        .querySelectorAll(".card.is-expanded")
        .forEach((c) => c.classList.remove("is-expanded"));
      cards.forEach((c) => {
        c.style.gridRowStart = "";
      });
      if (!isExpanded) {
        log("3a. expandiendo: aplicando gridRowStart y clase");
        const rect = firstRects.get(card) || card.getBoundingClientRect();
        const rowIndex = rowTops.findIndex((t) => Math.abs(t - Math.round(rect.top)) < 2);
        if (rowIndex !== -1) {
          card.style.gridRowStart = String(rowIndex + 1);
        }
        card.classList.add("is-expanded");
        expandedCard = card;
        // video se reproduce al terminar la animación para no bloquear (video pesado)
      } else {
        log("3a. colapsando");
        expandedCard = null;
        const video = card.querySelector(".card-video");
        if (video) {
          video.pause();
          setTimeout(() => {
            video.load();
          }, 300);
        }
      }

      const animations = [];
      if (!reduceMotion) {
        log("4. encolando rAF para animaciones");
        requestAnimationFrame(() => {
          log("5. rAF: iniciando animaciones, cards=", cards.length);
          const isExpanding = !isExpanded;
          cards.forEach((c) => {
            const first = firstRects.get(c);
            const last = c.getBoundingClientRect();
            if (!first) return;
            const isTarget = c === card;
            const sx = first.width / last.width;
            const sy = first.height / last.height;
            const useScale = isTarget && (sx !== 1 || sy !== 1);
            const originRect = isExpanding ? first : last;
            const isRight =
              originRect.left + originRect.width / 2 >= gridCenterX;
            const origin = isRight ? "top right" : "top left";
            const dx = isRight ? first.right - last.right : first.left - last.left;
            const dy = isTarget ? 0 : first.top - last.top;
            if (dx || dy || useScale) {
              const anim = c.animate(
                [
                  {
                    transform: useScale
                      ? `translate(${dx}px, ${dy}px) scale(${sx}, ${sy})`
                      : `translate(${dx}px, ${dy}px)`,
                    transformOrigin: origin,
                  },
                  {
                    transform: useScale
                      ? "translate(0, 0) scale(1, 1)"
                      : "translate(0, 0)",
                    transformOrigin: origin,
                  },
                ],
                  { duration: expandDuration, easing: expandEasing }
              );
              animations.push(anim);
            }
          });
          log("6. animaciones lanzadas:", animations.length);

          if (animations.length) {
            Promise.all(animations.map((anim) => anim.finished))
              .then(() => {
                log("7. animaciones terminadas, finalizeMissingSlots");
                finalizeMissingSlots(runId);
                const expanded = document.querySelector(".card.is-expanded");
                if (expanded) {
                  const video = expanded.querySelector(".card-video");
                  if (video) {
                    log("7b. video.play() tras animación");
                    video.play().catch((e) => log("video.play error", e));
                  }
                }
              })
              .catch((e) => {
                log("7. animaciones error", e);
                finalizeMissingSlots(runId);
              });
          } else {
            log("7. sin animaciones, finalizeMissingSlots directo");
            finalizeMissingSlots(runId);
            const expanded = document.querySelector(".card.is-expanded");
            if (expanded) {
              const video = expanded.querySelector(".card-video");
              if (video) {
                log("7b. video.play() tras animación");
                video.play().catch((e) => log("video.play error", e));
              }
            }
          }
        });
      }
      if (reduceMotion) {
        finalizeMissingSlots(runId);
      }
      log("8. toggleExpand fin (sync)");
    };

    cards.forEach((card) => {
      card.addEventListener("click", (event) => {
        const expanded = card.classList.contains("is-expanded");
        if (!expanded && !card.matches(":hover")) return; // expandir solo con hover
        if (event.target.closest(".cta")) {
          event.preventDefault();
        }
        log("0. click en card");
        toggleExpand(card);
      });
    });

    const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    let activeFilter = "all";

    const applyFilter = (filter) => {
      const grid = document.querySelector(".grid");
      const leaveDuration = 300; // velocidad de aparición/desaparición
      const cardRects = new Map();
      const matchesMap = new Map();
      const enteringCards = new Set();
      const gridRect = grid.getBoundingClientRect();
      const firstRects = new Map();

      cards.forEach((card) => {
        cardRects.set(card, card.getBoundingClientRect());
        const tags = (card.dataset.tags || "").split(",").map((t) => t.trim());
        const matches = filter === "all" || tags.includes(filter);
        matchesMap.set(card, matches);
        if (!reduceMotion && matches) {
          firstRects.set(card, cardRects.get(card));
        }
      });

      cards.forEach((card) => {
        const matches = matchesMap.get(card);
        const wasRemoved = card.classList.contains("is-removed");

        if (matches) {
          if (wasRemoved) {
            enteringCards.add(card);
            card.classList.add("is-entering");
            requestAnimationFrame(() => card.classList.remove("is-entering"));
          }
          card.classList.remove("is-removed", "is-hidden", "is-leaving");
          card.style.position = "";
          card.style.top = "";
          card.style.left = "";
          card.style.width = "";
          card.style.height = "";
          return;
        }

        const rect = cardRects.get(card);
        const top = rect.top - gridRect.top;
        const left = rect.left - gridRect.left;
        card.style.position = "absolute";
        card.style.top = `${top}px`;
        card.style.left = `${left}px`;
        card.style.width = `${rect.width}px`;
        card.style.height = `${rect.height}px`;
        card.classList.add("is-leaving");
        requestAnimationFrame(() => card.classList.add("is-hidden"));

        setTimeout(() => {
          if (!matchesMap.get(card)) {
            card.classList.remove("is-leaving", "is-hidden");
            card.classList.add("is-removed");
            card.style.position = "";
            card.style.top = "";
            card.style.left = "";
            card.style.width = "";
            card.style.height = "";
          }
        }, leaveDuration);
      });

      if (!reduceMotion) {
        requestAnimationFrame(() => {
          cards.forEach((card) => {
            if (!matchesMap.get(card)) return;
            if (enteringCards.has(card)) return; // B solo: no animar reacomodo
            const first = firstRects.get(card);
            const last = card.getBoundingClientRect();
            if (!first) return;
            const dx = first.left - last.left;
            const dy = first.top - last.top;
            if (dx || dy) {
              card.animate(
                [
                  { transform: `translate(${dx}px, ${dy}px)` },
                  { transform: "translate(0, 0)" },
                ],
                { duration: 820, easing: "cubic-bezier(0.2, 0.7, 0.2, 1)" } // velocidad del reacomodo (sube este duration)
              );
            }
          });
        });
      }
      requestAnimationFrame(() => updateCardPositions(false, false));
    };

    requestAnimationFrame(() => updateCardPositions(false, false));

    document.querySelectorAll(".card-tag").forEach((tag) => {
      tag.addEventListener("click", (event) => {
        event.stopPropagation();
        const label = tag.textContent.trim().toLowerCase();
        activeFilter = activeFilter === label ? "all" : label;
        applyFilter(activeFilter);
      });
    });
  </script>
</body>
</html>
